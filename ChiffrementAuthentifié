import codecs, random, sys, hmac, hashlib, base64, binascii

##########################################################################################
#                                       SHA3                                             #
##########################################################################################

def Text2Bits(text, encoding='utf-8', errors='surrogatepass'):
    bits = bin(int(binascii.hexlify(text.encode(encoding, errors)), 16))[2:]
    return bits.zfill(8 * ((len(bits) + 7) // 8))

def Bits2Text(bits, encoding='utf-8', errors='surrogatepass'):
    n = int(bits, 2)
    return int2bytes(n).decode(encoding, errors)

def int2bytes(i):
    hex_string = '%x' % i
    n = len(hex_string)
    return binascii.unhexlify(hex_string.zfill(n + (n & 1)))

def padding(M,r):
    """Ajoute du padding a un message quelconque afin de le rendre de taille multiple de r."""

    val = len(M + '11') % r
    res = M + '1' + '0'*((r-val)%r) + '1'
    return res


def toBlock(M, r):
    """Transforme un message de taille multiple de r en un tableau de partie de message tous de taille r."""

    k = len(M) // r
    m = [M[r*i:r*(i+1)] for i in range(k)]
    return m


def xor(block, m, r):
    """Realise un xor bit a bit entre un block de taille > r et un message de taille r."""

    res = [block[i] for i in range(len(block))]
    for i in range(r):
        res[i] = str(int(block[i])^int(m[i]))
    return res


def transformation(block):
    """Transforme un block de 1600 bits en une matrice 3 dimension 5*5*64."""

    res = [['0'*64 for i in range(5)] for i in range(5)]
    for ligne in range(5):
        for colonne in range(5):
            res[ligne][colonne] = block[ligne*320+colonne*64:64+ligne*320+colonne*64]
    return res


def detransformation(matrice):
    """Transforme une matrice 3 dimension 5*5*64 en un block de 1600 bits."""

    res = ''
    for ligne in range(5):
        for colonne in range(5):
            res += matrice[ligne][colonne]
    return res


def cp(matrice, x, z):
    """Calcul de la parité de la colonne situé à l'emplacement x, z."""

    res = str(
    int(matrice[x][0][z]) ^
    int(matrice[x][1][z]) ^
    int(matrice[x][2][z]) ^
    int(matrice[x][3][z]) ^
    int(matrice[x][4][z])
    )
    return res


def theta(matrice):
    """Fonction theta de Keccak realisé sur une matrice de 1600 bits découpé en matrice 5*5*64. Réalisation d'un ensemble de xor sur les différents bits de la matrice."""

    res = [['0'*64 for i in range(5)] for i in range(5)]
    for x in range(5):
        for y in range(5):
            for z in range(64):
                res[x][y] = res[x][y][:z] + \
                str(int(matrice[x][y][z]) ^ int(cp(matrice, (x+1)%5, (z-1)%64)) ^ int(cp(matrice, (x-1)%5, z)))
    return res


def rho(matrice):
    """Fonction rho de Keccak réalisé sur une matrice de 1600 bits découpée en matrice 5*5*64. Réalisation d'un ensemble de rotation sur les mots de 64 bits dans la matrice 5*5."""

    rotation = [[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]]
    res = [['0'*64 for i in range(5)] for i in range(5)]
    for x in range(5):
        for y in range(5):
            res[x][y] = matrice[x][y][rotation[x][y]:] + matrice[x][y][:rotation[x][y]]
    return res


def pi(matrice):
    """Fonction pi de Keccak réalisé sur une matrice de 1600 bits découpée en matrice 5*5*64. Réalisation d'un mélange des mots de 64 bits dans la matrice 5*5."""

    res = [['0'*64 for i in range(5)] for i in range(5)]
    for x in range(5):
        for y in range(5):
            res[y][(2*x+3*y)%5] = matrice[x][y]
    return res


def khi(matrice):
    """Fonction khi de Keccak réalisé sur une matrice de 1600 bits découpée en matrice 5*5*64. Réalisation d'un ensemble d'opération sur les différents bits de la matrice."""

    res = [['0'*64 for i in range(5)] for i in range(5)]
    for x in range(5):
        for y in range(5):
            for z in range(64):
                res[x][y] = res[x][y][:z] + \
                str(int(matrice[x][y][z]) ^ ((int(matrice[(x+1)%5][y][z]) ^ 1) & int(matrice[(x+2)%5][y][z])))
    return res


def hexToBin(hexa):
    """Transforme un nombre en hexadecimal en un mot de 64 bits."""

    res = bin(hexa)[2:]
    res = '0'*(64-len(res))+res
    return res


def iota(matrice, roundNb):
    """Fonction iota de Keccak réalisé sur une matrice de 1600 bits découpée en matrice 5*5*64. Ajout d'une constante sur la 1ere ligne de la matrice 5*5 (située en 0,0)."""

    RC = [
    0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
    0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
    0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
    0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
    0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
    0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
    0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
    0x8000000000008080, 0x0000000080000001, 0x8000000080008008]

    binRC = hexToBin(RC[roundNb])

    res = [[matrice[j][i] for i in range(5)] for j in range(5)]
    for z in range(64):
        res[0][0] = res[0][0][:z] + \
        str(int(matrice[0][0][z]) ^ int(binRC[z]))
    return res


def f(block, nbRound):
    """Fonction de permutation de Keccak."""
    #print(block)
    matrice = transformation(block)
    #print(matrice)
    for i in range(nbRound):
        matrice = theta(matrice)
        matrice = rho(matrice)
        matrice = pi(matrice)
        matrice = khi(matrice)
        matrice = iota(matrice, i)
        res = detransformation(matrice)
    return res
##Sha3-512 : r = 576; c = 1024
##Sha3-384 : r = 832; c = 768
##Sha3-256 : r = 1088; c = 512
##Sha3-224 : r = 1152; c = 448

def sha3(M, version):
    v = {512:576, 384:832, 256:1088, 224:1152}
    if (not version in v):
        print('Version non valide pour Keccak.')
        exit(1)
    else:
        r = v[version]
        #c = 1600-r

    M = Text2Bits(M)
    tmp = padding(M, r)
    ensMessage = toBlock(tmp, r)
    block = '0'*1600

    for m in ensMessage:
        block = xor(block, m, r)
        block = f(block, 24)

    res = block[:version]
    final = ''
    i = 0
    while(i < 512):
        hexa = hex(int(res[i:i + 8], 2))[2:]
        if(len(hexa) == 1):
            hexa = '0' + hexa
        final += hexa
        i += 8

    return final.upper()

##########################################################################################
#                                    MIDORI                                              #
##########################################################################################

sbox = [0xc, 0xa, 0xd, 0x3, 0xe, 0xb, 0xf, 0x7, 0x8, 0x9, 0x1, 0x5, 0x0, 0x2, 0x4, 0x6]

p = [0, 10, 5, 15, 14, 4, 11, 1, 9, 3, 12, 6, 7, 13, 2, 8]
invP = [0, 7, 14, 9, 5, 2, 11, 12, 15, 8, 1, 6, 10, 13, 4, 3]

a0 = [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1]
a1 = [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]
a2 = [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1]
a3 = [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1]
a4 = [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1]
a5 = [1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0]
a6 = [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0]
a7 = [0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0]
a8 = [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]
a9 = [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0]
a10 = [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1]
a11 = [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0]
a12 = [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0]
a13 = [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0]
a14 = [1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0]
alpha = [a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14]


def subCell(mot):
    return sbox[mot]


def subCells(matrice):
    res = [0 for i in range(16)]
    for j in range(16):
        res[j] = subCell(matrice[j])
    return res


def shuffleCells(matrice):
    res = [0 for i in range(16)]
    for i in range(16):
        res[i] = matrice[p[i]]
    return res


def reverseShuffleCells(matrice):
    res = [0 for i in range(16)]
    for i in range(16):
        res[i] = matrice[invP[i]]
    return res


def mixColumn(matrice):
    res = [0 for i in range(16)]
    for i in range(4):
        res[0 + 4 * i] = matrice[1 + 4 * i] ^ matrice[2 + 4 * i] ^ matrice[3 + 4 * i]
        res[1 + 4 * i] = matrice[0 + 4 * i] ^ matrice[2 + 4 * i] ^ matrice[3 + 4 * i]
        res[2 + 4 * i] = matrice[0 + 4 * i] ^ matrice[1 + 4 * i] ^ matrice[3 + 4 * i]
        res[3 + 4 * i] = matrice[0 + 4 * i] ^ matrice[1 + 4 * i] ^ matrice[2 + 4 * i]
    return res


def addKey(matrice, key):
    res = [0 for i in range(16)]
    for i in range(16):
        res[i] = matrice[i] ^ key[i]
    return res


def midori64(m, k):
    wk = addKey(k[0:16], k[16:32])
    rk = [0 for i in range(16)]

    res = addKey(m, wk)
    for i in range(15):
        rk = addKey(k[0 + 16 * (i % 2): 16 + 16 * (i % 2)], alpha[i])
        res = subCells(res)
        res = shuffleCells(res)
        res = mixColumn(res)
        res = addKey(res, rk)
    res = subCells(res)
    res = addKey(res, wk)
    return res


def reverseMidori(m, k):
    wk = addKey(k[0:16], k[16:32])
    rk = [0 for i in range(16)]

    res = addKey(m, wk)
    for i in range(14, -1, -1):
        rk = addKey(k[0 + 16 * (i % 2): 16 + 16 * (i % 2)], alpha[i])
        res = subCells(res)
        res = mixColumn(res)
        res = reverseShuffleCells(res)
        tmpRK = reverseShuffleCells(mixColumn(rk))
        res = addKey(res, tmpRK)
    res = subCells(res)
    res = addKey(res, wk)
    return res

##########################################################################################
#                                     Mode opératoire                                    #
##########################################################################################

def xor2Block(b, c):
    res = []
    for i in range(0, len(b)):
        res.append(b[i] ^ c[i])
    return res

##La cle doit être générée par une fonction de dérivation de clés, à partir d'un mdp (input)
##Pareil pour l'IV et pour la clé du Hash
def CBC(plain, cle, IV):
    msg = []
    block = []
    cpt = 0
    msgChiffre = ""

    for c in plain:
        hexa = int(hex(ord(c)), base=16)
        high = hexa >> 4
        low = hexa & 0xF

        block.append(high)
        block.append(low)
        cpt = cpt + 2

        ##Ajout du block dans le tableau et réinitialisation du block
        if(cpt > 15):
            msg.append(block)
            block = []
            cpt = 0

    ##Padding
    if(cpt < 15):
        while(cpt < 16):
            block.append(0x0)
            cpt = cpt + 1
        msg.append(block)

    ##Chiffrement des blocs
    block = IV
    for b in msg:
        block = midori64(xor2Block(b, block), cle)
        for c in block:
            msgChiffre = msgChiffre + hex(c)[2:]
    return msgChiffre.upper()

def reverseCBC(cipher, cle, IV):
    tabBlock = []
    block = []
    final = ""
    cpt = 0

    ##Récupération sous forme de blocs du chiffré
    for c in cipher:
        block.append(int(c, base=16))
        cpt = cpt + 1
        if(cpt > 15):
            tabBlock.append(block)
            block = []
            cpt = 0

    ##A partir d'ici block nous sert de block pour le xor
    blockToXor = IV
    cpt = 0
    tmp = ""
    ##Déchiffrement de chaque bloc avec reverseMidori
    for b in tabBlock:
        block = reverseMidori(b, cle)
        block = xor2Block(block, blockToXor)
        blockToXor = b
        for c in block:
            tmp2 = tmp
            tmp = str(c)
            cpt = cpt + 1
            if(cpt > 1):
                cpt = 0
                if(int(tmp) == 0 & int(tmp2) == 0):
                    break

                if(len(tmp2) > 1 & len(tmp) > 1):
                    tmp = codecs.decode(hex(int(tmp2))[2:] + hex(int(tmp))[2:], "hex").decode('utf-8')
                    final = final + tmp

                if(len(tmp) > 1):
                    tmp = codecs.decode(tmp2 + hex(int(tmp))[2:], "hex").decode('utf-8')
                    final = final + tmp

                elif(len(tmp2) > 1):
                    tmp = codecs.decode(hex(int(tmp2))[2:] + tmp, "hex").decode('utf-8')
                    final = final + tmp

                else:
                    tmp = codecs.decode(tmp2+tmp, "hex").decode('utf-8')
                    final = final + tmp

    return final


##Fonction de dérivation de clé/vecteurs d'initialisation à partir d'un mdp (8 caractères)
##En CBC taille vecteur d'initialisation = taille du bloc

##########################################################################################
#                             Fonction de dérivation de clés                             #
##########################################################################################

def genKey(mdp):
    alea = int(hex(ord(mdp[:1])), base=16) & 0xFF
    res = mdp + str(alea)
    print(res)
    res = sha3(res, 512)
    return res

print(genKey('salut'))

key1 = [0x6, 0x8, 0x7, 0xd, 0xe, 0xd, 0x3, 0xb, 0x3, 0xc, 0x8, 0x5, 0xb, 0x3, 0xf, 0x3,
        0x5, 0xb, 0x1, 0x0, 0x0, 0x9, 0x8, 0x6, 0x3, 0xe, 0x2, 0xa, 0x8, 0xc, 0xb, 0xf]

cipher = CBC("salutsava", key1, [0 for i in range(16)])
print(cipher)
dechipher = reverseCBC(cipher, key1, [0 for i in range(16)])
print(dechipher)

#if __name__ == '__main__':
#    msg = input("Entrez le message à chiffrer :")
#    print(msg)
#    passwd = input("Entrez un mot de passe :")
